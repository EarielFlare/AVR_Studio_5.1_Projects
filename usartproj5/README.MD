Блок функций для работы с USART.

Для работы используется плата Arduino Nano, имеющая на борту чип AtMega328pa, а также чип CH340G для связи по USART с компом.
Плата была выбрана просто потому, что на ней уже все запаяно как надо. При этом бутлоадер Ардуино конечно же не используется, прошивка программы идет из IDE AVR Studio 5.1 с использованием программатора USBASP.

МК довольно простой и мелкий, поэтому сложных средств отладки не предоставляет. Я предпочитаю все отлаживать сразу на железе (без симуляций), поэтому мне нужно средство простейшей диагностики, некий диагностический prinf, который позволит получать данные о работе функций, значения параметров, и все такое.

Представленный здесь код позволяет получать данные по USART во время работы МК. Прием данных происходит в терминал. Поскольку разработка ведется из-под винды, программа-терминал выбрана Terminal v1.9b (https://robotchip.ru/terminal-1-9b/). Если вывод происходит кракозябрами, значит не совпадает скорость передачи данных. В терминале нужно выставить Baud rate 9600, шрифт (Set font) можно любой, например Calibri, обычный, высота 12, Кириллица. Если после этого кракозябры - неверно настроена скорость работы на МК. Сверьте частоту работы вашего МК с параметром F_CPU, напишите туда ваше реальное значение.

Не знаете реальное значение? Открываем программу для чтения фьюз битов, например AVRDUDEPROG.EXE (http://download.savannah.gnu.org/releases/avrdude/). Смотрим на блок Fuse Low Byte, параметры CKDIV, CKSEL, SUT. Выставляем их в соответствии с даташитом на ваш МК. Также необходимо правильно написать аргументы avrdude для прошивки МК с помощью USBASP (см. комменты в хедере usartproj5.h). В моем случае все работает от внешнего кварца на 16MHz в режиме Full Swing.

Собственно, о самом коде. Всего я сделал 2 функции вывода информации: diag_print и disr_print. Обе они принимают по 2 аргумента (строка, число), где строка - это произвольное описание, число - аргумент типа int16_t. В чем разница между этими функциями?

diag_print выводит сообщение и число по одному символу, отправляя их в терминал. При этом не используется никаких буферов под строку, не выделяется память в куче, происходит простой побайтовый вывод. Минус этой функции в том, что она работает ровно столько времени, сколько нужно интерфейсу USART для передачи сообщения. Если такую функцию использовать в поллинге эпизодически, все будет нормально. Однако если такая функция используется в часто вызываемых функциях, а также если ваша функция должна отрабатывать максимально быстро, такая способ отправки сообщения в терминал будет создавать существенную задержку (несколько миллисекунд).
