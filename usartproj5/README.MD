# Блок функций для работы с USART

Для работы используется плата Arduino Nano, имеющая на борту чип AtMega328pa, а также чип CH340G для связи по USART с компом.
Плата была выбрана просто потому, что на ней уже все запаяно как надо. При этом бутлоадер Ардуино конечно же не используется, прошивка программы идет из IDE AVR Studio 5.1 с использованием программатора USBASP.

МК довольно простой и мелкий, поэтому сложных средств отладки не предоставляет. Я предпочитаю все отлаживать сразу на железе (без симуляций), поэтому мне нужно средство простейшей диагностики, некий диагностический prinf, который позволит получать данные о работе функций, значения параметров, и все такое.

Представленный здесь код позволяет получать данные по USART во время работы МК. Прием данных происходит в терминал. Поскольку разработка ведется из-под винды, программа-терминал выбрана Terminal v1.9b (https://robotchip.ru/terminal-1-9b/). Если вывод происходит кракозябрами, значит не совпадает скорость передачи данных. В терминале нужно выставить Baud rate 9600, шрифт (Set font) можно любой, например Calibri, обычный, высота 12, Кириллица. Если после этого кракозябры - неверно настроена скорость работы на МК. Сверьте частоту работы вашего МК с параметром F_CPU, напишите туда ваше реальное значение.

Не знаете реальное значение? Открываем программу для чтения фьюз битов, например AVRDUDEPROG.EXE (http://download.savannah.gnu.org/releases/avrdude/). Смотрим на блок Fuse Low Byte, параметры CKDIV, CKSEL, SUT. Сверяем / выставляем их в соответствии с даташитом на ваш МК. Также в среде AVR Studio 5.1 (Tools->External Tools) необходимо правильно написать аргументы avrdude для прошивки МК с помощью USBASP (см. комменты в хедере usartproj5.h). В моем случае все работает от внешнего кварца на 16MHz в режиме Full Swing.

Собственно, о самом коде. Всего я сделал 2 функции вывода информации: diag_print и disr_print. Обе они принимают по 2 аргумента (строка, число), где строка - это произвольное описание, число - аргумент типа int16_t. В чем разница между этими функциями?

diag_print выводит сообщение и число по одному символу, отправляя их в терминал. При этом не используется никаких буферов под строку, не выделяется память в куче, происходит простой побайтовый вывод. Минус этой функции в том, что она работает ровно столько времени, сколько нужно интерфейсу USART для передачи сообщения. Если такую функцию использовать в поллинге эпизодически, все будет нормально. Однако если такая функция используется в часто вызываемых функциях, а также если ваша функция должна отрабатывать максимально быстро, такой способ отправки сообщения в терминал будет создавать существенную задержку (несколько миллисекунд).

disr_print использует прерывания для выода сообщения в терминал. Непосредственно само сообщение подготавливается в рамках функции disr_print. На основе переданных функции параметров (строка и аргумент типа uint16_t) формируется буфер символов длиной MAXBUF, после чего запускается последовательность побайтового вывода этих символов по прерываниям USART: ISR(USART_UDRE_vect), ISR(USART_TX_vect). Таким образом, Функция не требует ожидания вывода всех байтов сообщения сразу, а может выполняться псевдопараллельно основному циклу и другим функциям.

Важно отметить, что функция disr_print использует для работы динамически выделяемую память. Однако malloc используется исключительно внутри функции disr_print при подготовке двух строк, здесь же происходит высвобождение памяти (free). Почему не использовать такой же метод при подготовке буфера на вывод в USART? Причина в том, что в таком случае высвобождение памяти под буфер будет происходить в конце вывода сообщения. При отсутствии задержек количество вызовов функции disr_print может быть настолько высоким, что сообщение так и не будет выведено (оно будет перебиваться новым сообщением), при этом функция почти мгновенно заполнит всю память созданными строками. Поэтому любая работа по выделению памяти происходит только внутри функции, и здесь же завершается. Сообщение на вывод копируется в глобальную переменную (массив), и даже в случае частых выводов функции disr_print это не приведет к фатальным проблемам. Худшее, что может случиться - сообщение будет перебиваться своими новыми версиями. Важно следить за частотой вывода таких сообщений, это забота программиста. Длина сообщения может быть задана макросом MAXBUF.
